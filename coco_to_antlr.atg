/*-------------------------------------------------------------------------
Coco.ATG -- Attributed Grammar
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported to C++ by Csaba Balazs, University of Szeged
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than 
Coco/R itself) does not fall under the GNU General Public License.
-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------
 compile with:
   Coco Coco.ATG -namespace Coco
-------------------------------------------------------------------------*/

#include <ostream>
#include <sstream>
#include <iostream>
#include <functional>
#include "common.h"

COMPILER Coco

std::reference_wrapper<std::wostream> output_stream = std::ref(std::wcout);

std::wostream& output() {
	return output_stream.get();
}

wchar_t* copy_verbatim(int pos_start, int pos_end) {
	return scanner->buffer->GetString(pos_start, pos_end);
}

// buffer these sections to output them *after* the parser for ANTLR
std::wstringstream characters, tokens;

size_t literal_token_index = 0;

bool in_verbatim = true;


// maps from coco character set names to their uppercase-variant as used for ANTLR
UBiMap<std::wstring, std::wstring> charset_names;
// maps from coco token names to their uppercase-variant as used for ANTLR
UBiMap<std::wstring, std::wstring> token_names;
// maps from coco production rule names to their uppercase-variant as used for ANTLR
UBiMap<std::wstring, std::wstring> production_names;

/**
 * @return the name to be used in ANTLR instead of coco_name
 * @param in_section which section the name was defined in, i.e. what type it has.
 *  NOTE: assumes that once we got into tokens section, no more charsets are defined, similarly for token & production
 */
std::wstring define_name(name_type in_section, const std::wstring& coco_name) {
    switch (in_section) {
        case name_type::charset:
            if(charset_names.contains_key(coco_name)) {
                return charset_names.at(coco_name);
            } else {
                const auto antlr_name_raw = toUpperCase(coco_name);
                auto antlr_name = antlr_name_raw;
                size_t i = 2;
                while (charset_names.contains_value(antlr_name)) {
                    antlr_name = antlr_name_raw + L"_" + std::to_wstring(i);
                    ++i;
                }
                charset_names.insert(coco_name, antlr_name);
                return antlr_name;
            }
        case name_type::token:
            if(token_names.contains_key(coco_name)) {
                return token_names.at(coco_name);
            } else {
                const auto antlr_name_raw = toUpperCase(coco_name);
                auto antlr_name = antlr_name_raw;
                size_t i = 2;
                while (charset_names.contains_value(antlr_name)
                       || token_names.contains_value(antlr_name)) {
                    antlr_name = antlr_name_raw + L"_" + std::to_wstring(i);
                    ++i;
                }
                token_names.insert(coco_name, antlr_name);
                return antlr_name;
            }
        case name_type::production:
            if(production_names.contains_key(coco_name)) {
                return production_names.at(coco_name);
            } else {
                const auto antlr_name_raw = toLowerCase(coco_name);
                auto antlr_name = antlr_name_raw;
                size_t i = 2;
                while (production_names.contains_value(antlr_name)
                       || token_names.contains_value(antlr_name)) {
                    antlr_name = antlr_name_raw + L"_" + std::to_wstring(i);
                    ++i;
                }
                production_names.insert(coco_name, antlr_name);
                return antlr_name;
            }
    }
}


std::wstring toUpperCase(std::wstring str) {
    std::transform(str.begin(), str.end(), str.begin(),
                   [](unsigned char c) { return std::toupper(c); });
    return str;
}

std::wstring toLowerCase(std::wstring str) {
    std::transform(str.begin(), str.end(), str.begin(),
                   [](unsigned char c) { return std::tolower(c); });
    return str;
}

CHARACTERS
	letter    = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_".
	digit     = "0123456789".
	cr        = '\r'.
	lf        = '\n'.
	tab       = '\t'.
	stringCh  = ANY - '"' - '\\' - cr - lf.
	charCh    = ANY - '\'' - '\\' - cr - lf.
	printable =  '\u0020' .. '\u007e'.
	hex       = "0123456789abcdef".

	other = ANY - '/' - '*'.
	no_lf = ANY - lf.

TOKENS
	ident     = letter { letter | digit }.
	number    = digit { digit }.
	string    = '"' { stringCh | '\\' printable } '"'.
	badString = '"' { stringCh | '\\' printable } (cr | lf).
	char      = '\'' ( charCh | '\\' printable { hex } ) '\''.

PRAGMAS
	ddtSym    = '$' { digit | letter }.
	optionSym = '$' letter { letter } '='
	            { digit | letter
	            | '-' | '.' | ':'
	            }.

	comment1 = "/*" {'/' | other | '*' {'*'} other} '*' {'*'} '/'. // NESTED not supported!
		(. if(!in_verbatim) output() << la->val; .)
	comment2 = "//" { no_lf } lf.
		(. if(!in_verbatim) output() << la->val; .)

IGNORE cr + lf + tab

/*-------------------------------------------------------------------------*/

PRODUCTIONS

Coco
=
                                (. auto pos_start_includes = la->pos; .)
  { ANY }                       (. auto pos_end_includes = la->pos;
                                   in_verbatim = false;
                                .)
                                
  "COMPILER" ident              (. output() << "grammar " << t->val << ";\n\n"
                                            << "@parser::header {\n" << copy_verbatim(pos_start_includes, pos_end_includes) << "\n}\n";

                                   auto pos_start_members = la->pos;
                                   in_verbatim = true;
                                .)
  { ANY }                       (. in_verbatim = false;
                                   output() << "@parser::members {\n"
                                            << copy_verbatim(pos_start_members, la->pos) << "\n}\n";
                                .)

  [ "IGNORECASE"                (. output() << "//" C2A_TODO ": IGNORECASE not possible in ANTLR, see doc/case-insensitive-lexing.md\n"; .)
  ]
  [ "CHARACTERS"                (. characters << "// CHARACTERS from line " << std::to_wstring(t->line) << '\n'; .)
    { SetDecl }
  ]

  [ "TOKENS"                    (. tokens << "// TOKENS from line " << std::to_wstring(t->line) << '\n'; .)
    { TokenDecl }
  ]
  [ "PRAGMAS"                   (. tokens << "// PRAGMAS from line " << std::to_wstring(t->line) << '\n'; .)
    { TokenDecl }
  ]
  { "COMMENTS"                  (. tokens << "// COMMENTS from line " << std::to_wstring(t->line) << '\n';
                                   tokens << define_name(name_type::token, L"COMMENT_" + std::to_wstring(t->pos)) << ": (";
                                .)
    "FROM" TokenExpr            (.  tokens << " .*? "; .)
    "TO" TokenExpr
    [ "NESTED"                  (. tokens << "/* " C2A_TODO ": implement NESTED for this COMMENT */\n"; .)
    ]                           (. tokens << ") -> channel(HIDDEN);\n"; .)
  }
  { "IGNORE"                    (. tokens << "// IGNORE from line " << std::to_wstring(t->line) << '\n';
                                   tokens << define_name(name_type::token, L"IGNORE") << ": (";
                                .)
    Set<tokens>                  (. tokens  << ") -> skip;\n"; .)
  }

  SYNC 
  "PRODUCTIONS"                 (. output() << "// PRODUCTIONS from line " << std::to_wstring(t->line) << '\n'; .)
  { Production }
  "END" ident                   (. output() << "\n\n" << tokens.str() << "\n\n" << characters.str(); .)
  '.'
.


Production
=
	ident                       (. output() << define_name(name_type::production, std::wstring(t->val)); .)
	[ AttrDecl ]
                                (. output() << ":\n\t"; .)
    [ SemText<output()> ]
    WEAK '='
    Expression
    WEAK '.'                    (. output() << ";\n\n"; .)
.


/*------------------------------------------------------------------------------------*/

SetDecl
=
  ident                         (. characters << "fragment " << define_name(name_type::charset, t->val)
                                              << ":\n\t";
                                .)
  '=' Set<characters>
  '.'                           (. characters << "\n\t;\n\n"; .)
.

/*------------------------------------------------------------------------------------*/

Set<std::wostream& output_to>
=
  SimSet<output_to>
  { '+'                         (. output_to << "\n\t| "; .)
    SimSet<output_to>
  | '-'                         (. output_to << " /*" C2A_TODO ": this subset was negated, reformulate for ANTLR! */( "; .)
    SimSet<output_to>          (. output_to << ") "; .)
  }
.

/*------------------------------------------------------------------------------------*/

SimSet<std::wostream& output_to>
=
( ident                         (. if(charset_names.contains_key(t->val))
                                       output_to << charset_names.at(t->val);
                                .)
|                               (. std::wstring chars; .)
  String<chars, output_to>      (. // remove "-" if in chars, because in ANTLR it denotes character range
                                   auto removed = std::remove(chars.begin(), chars.end(), '-');
                                   if(removed != chars.end())
                                       output_to << "'-' | ";
                                   chars.erase(removed, chars.end());

                                   output_to << "[" << chars << "]";
                                .)
|                               (. std::wstring name; .)
  Char<name, output_to>         (. output_to << name; .)
  [ ".." Char<name, output_to>  (. output_to << ".." << name; .)
  ]
| "ANY"                         (. output_to << " . "; .)
)
.

Char<std::wstring& name, std::wostream& output_to>
=
	char                        (. name = std::wstring(t->val);

                                   if(name.find(L"\\") != std::wstring::npos)
                                       output_to << "/*" C2A_TODO ": escaped character, check if meaning correct: */ ";
                                .)
.

String<std::wstring& name, std::wostream& output_to>
=   string                      (. name = std::wstring(t->val);
                                   name = name.substr(1, name.length() -2); // remove ""
                                   if(name.find(L"\\") != std::wstring::npos)
                                       output_to << "/*" C2A_TODO ": escaped characters in string, check if meaning correct */ ";
                                .)
.

/*------------------------------------------------------------------------------------*/

TokenDecl                       (. std::wstring name; bool is_literal; .)
=
  Sym<name, is_literal, tokens>
                                (. if(is_literal) {
                                       // raw string or char token, coco has no name for it
                                       tokens << "LITERAL_" << std::to_wstring(literal_token_index)
                                              << ": " << name;
                                       ++literal_token_index;
                                   } else {
                                       tokens << define_name(name_type::token, name) << ": ";
                                   }
                                .)
  SYNC
  ( '=' TokenExpr '.'           (. tokens << "\n\t"; .)
  |                             (. tokens << " //" C2A_TODO ": named token without body from Coco\n"; .)
  )
  [
    SemText<tokens>
  ]
                                (. tokens << ";\n\n"; .)
.

/*------------------------------------------------------------------------------------*/

AttrDecl //TODO: parameter conflicts with rule with same name
=
  '<'                           (. auto pos_start = la->pos;
                                   output() << "[";
                                   in_verbatim = true;
                                .)
  { ANY | badString }
  '>'                           (. output() << copy_verbatim(pos_start, t->pos) << "]";
                                   in_verbatim = false;
                                .)
| "<."                          (. auto pos_start = la->pos;
                                   output() << "[";
                                   in_verbatim = true;
                                .)
  { ANY | badString }
  ".>"                          (. output() << copy_verbatim(pos_start, t->pos) << "]";
                                   in_verbatim = false;
                                .)
.

/*------------------------------------------------------------------------------------*/

Expression
= 
  Term
  { WEAK '|'                    (. output() << "\n\t| "; .)
    Term
  }
.

Term
=
(   [ Resolver ]
	Factor
	{                           (. output() << "\n\t\t"; .)
		Factor
	}
|
)
.

Factor
=
( [ "WEAK" ]                    (. std::wstring name; bool is_literal; .)
  Sym<name, is_literal, output()>
                                (. if(is_literal) {
                                       output() << name;
                                   } else {
                                       if(token_names.contains_key(name)) {
                                           output() << token_names.at(name);
                                       } else {
                                           if(! production_names.contains_key(name)) {
                                               SemErr(std::wstring(L"name not defined yet: " + name).c_str()); // actually a warning only
                                           }
                                           output() << define_name(name_type::production, name);
                                       }
                                   }
                                 .)
  [ Attribs ]
| '('                           (. output() << "( "; .)
   Expression ')'               (. output() << " )"; .)
| '['                           (. output() << "( "; .)
   Expression ']'               (. output() << " )?"; .)
| '{'                           (. output() << "( "; .)
   Expression '}'               (. output() << " )*"; .)
| SemText<output()>
| "ANY"                         (. output() << " . "; .)
| "SYNC"
)
.

/*------------------------------------------------------------------------------------*/

Resolver
=
  "IF" "("                       (. auto pos_start = la->pos;
                                    output() << "/* " C2A_TODO "IF() conflict resolver from Coco, check ANTLR code:\n";
                                    in_verbatim = true;
                                 .)
  Condition                      (. output() << copy_verbatim(pos_start, la->pos) << "\n*/\n";
                                    in_verbatim = false;
                                 .)
.

Condition = { "(" Condition | ANY } ")" .

/*------------------------------------------------------------------------------------*/

TokenExpr
=
  TokenTerm
  {
    WEAK '|'                    (. tokens << "\n\t| "; .)
    TokenTerm
  }
.

TokenTerm
=
  TokenFactor
  { TokenFactor }
  [ "CONTEXT"               (. tokens << "/*" C2A_TODO ": CONTEXT specification not supported in ANTLR\n"; .)
    '(' TokenExpr           (. tokens << "*/\n"; .)
    ')'
  ]
.

TokenFactor                     (. std::wstring name; bool is_literal; .)
=
( Sym<name, is_literal, tokens>
                                (. if(is_literal) {
                                       tokens << name;
                                   } else {
                                       if (! charset_names.contains_key(name))
                                           SemErr(L"Character Class used but not defined");
                                       tokens << charset_names.at(name);
                                   }
                                .)
| '('                           (. tokens << "( "; .)
	TokenExpr ')'               (. tokens << " )"; .)
| '['                           (. tokens << "( "; .)
	TokenExpr ']'               (. tokens << " )?"; .)
| '{'                           (. tokens << "( "; .)
	TokenExpr '}'               (. tokens << " )*"; .)
)
.

/*------------------------------------------------------------------------------------*/

Sym<std::wstring& name, bool& is_literal, std::wostream& output_to>
=
( ident                         (. name = std::wstring(t->val);
                                   is_literal = false;
                                .)
| String<name, output_to>       (. name = L"'" + name + L"'";
                                   is_literal = true;
                                .)
| Char<name, output_to>         (. is_literal = true; .)
)
.

/*------------------------------------------------------------------------------------*/

Attribs
=
  '<'                           (. auto pos_start = la->pos;
                                   output() << "[";
                                   in_verbatim = true;
                                .)
  { ANY | badString }           (. output() << copy_verbatim(pos_start, la->pos) << "]";
                                   in_verbatim = false;
                                .)
  '>'
| "<."                          (. auto pos_start = la->pos;
                                   output() << "[";
                                   in_verbatim = true;
                                .)
  { ANY | badString }           (. output() << copy_verbatim(pos_start, la->pos) << "]";
                                   in_verbatim = false;
                                .)
  ".>"
.

SemText<std::wostream& output_to>
=
  "(."                          (. auto pos_start = la->pos;
	                               in_verbatim = true;
                                .)
  { ANY | badString | "(." }    (. output_to << "{ " << copy_verbatim(pos_start, la->pos) << " }\n";
	                               in_verbatim = false;
                                .)
  ".)"
.

END Coco.
