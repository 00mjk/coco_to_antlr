/*-------------------------------------------------------------------------
Coco.ATG -- Attributed Grammar
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported to C++ by Csaba Balazs, University of Szeged
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than 
Coco/R itself) does not fall under the GNU General Public License.
-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------
 compile with:
   Coco Coco.ATG -namespace Coco
-------------------------------------------------------------------------*/

#include <ostream>
#include <sstream>
#include <iostream>
#include <cassert>
#include <functional>
#include "common.h"

COMPILER Coco

std::reference_wrapper<std::wostream> output_stream = std::ref(std::wcout);
// buffer these sections to output them *after* the parser for ANTLR
std::wstringstream characters, tokens;

name_type current_output = name_type::production;
std::wostream& output() {
    switch(current_output) {
        case name_type::production:
            return output_stream.get();
        case name_type::token:
            return tokens;
        case name_type::charset:
            return characters;
    }
}


wchar_t* copy_verbatim(int pos_start, int pos_end) {
    return scanner->buffer->GetString(pos_start, pos_end);
}

size_t literal_token_index = 0;

bool in_verbatim = true;


// maps from coco character set names to their uppercase-variant as used for ANTLR
UBiMap<std::wstring, std::wstring> charset_names;
// maps from coco token names to their uppercase-variant as used for ANTLR
UBiMap<std::wstring, std::wstring> token_names;
// maps from coco production rule names to their uppercase-variant as used for ANTLR
UBiMap<std::wstring, std::wstring> production_names;

/**
 * @return the name to be used in ANTLR instead of coco_name
 * @param in_section which section the name was defined in, i.e. what type it has.
 *  NOTE: assumes that once we got into tokens section, no more charsets are defined, similarly for token & production
 */
std::wstring define_name(name_type in_section, const std::wstring& coco_name) {
    switch (in_section) {
        case name_type::charset:
            if(charset_names.contains_key(coco_name)) {
                return charset_names.at(coco_name);
            } else {
                auto antlr_name_raw = coco_name.substr(coco_name.find_first_not_of(L'_'));
                antlr_name_raw[0] = std::toupper((unsigned char) antlr_name_raw[0]);
                auto antlr_name = antlr_name_raw;
                size_t i = 2;
                while (charset_names.contains_value(antlr_name)) {
                    antlr_name = antlr_name_raw + L"_" + std::to_wstring(i);
                    ++i;
                }
                charset_names.insert(coco_name, antlr_name);
                return antlr_name;
            }
        case name_type::token:
            if(token_names.contains_key(coco_name)) {
                return token_names.at(coco_name);
            } else {
                auto antlr_name_raw = coco_name.substr(coco_name.find_first_not_of(L'_'));
                antlr_name_raw[0] = std::toupper((unsigned char) antlr_name_raw[0]);
                auto antlr_name = antlr_name_raw;
                size_t i = 2;
                while (charset_names.contains_value(antlr_name)
                       || token_names.contains_value(antlr_name)) {
                    antlr_name = antlr_name_raw + L"_" + std::to_wstring(i);
                    ++i;
                }
                token_names.insert(coco_name, antlr_name);
                return antlr_name;
            }
        case name_type::production:
            if(production_names.contains_key(coco_name)) {
                return production_names.at(coco_name);
            } else {
                auto antlr_name_raw = coco_name.substr(coco_name.find_first_not_of(L'_'));
                antlr_name_raw[0] = std::tolower((unsigned char) antlr_name_raw[0]);
                auto antlr_name = antlr_name_raw;
                size_t i = 2;
                while (production_names.contains_value(antlr_name)
                       || token_names.contains_value(antlr_name)) {
                    antlr_name = antlr_name_raw + L"_" + std::to_wstring(i);
                    ++i;
                }
                production_names.insert(coco_name, antlr_name);
                return antlr_name;
            }
    }
}


int indent_level = 0;

/** adjust current indent_level by @param increment (positive or negative).
  * @return whitespaces for current/new indentation level
  */
std::wstring indent(int increment = 0) {
    indent_level += increment;
    assert(indent_level >= 0);
    indent_level = std::max(0, indent_level);
    return std::wstring(indent_level, '\t');
}

CHARACTERS
    letter    = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_".
    digit     = "0123456789".
    cr        = '\r'.
    lf        = '\n'.
    tab       = '\t'.
    stringCh  = ANY - '"' - '\\' - cr - lf.
    charCh    = ANY - '\'' - '\\' - cr - lf.
    printable =  '\u0020' .. '\u007e'.
    hex       = "0123456789abcdef".

    other = ANY - '/' - '*'.
    no_lf = ANY - lf.

TOKENS
    ident     = letter { letter | digit }.
    number    = digit { digit }.
    string    = '"' { stringCh | '\\' printable } '"'.
    badString = '"' { stringCh | '\\' printable } (cr | lf).
    char      = '\'' ( charCh | '\\' printable { hex } ) '\''.

PRAGMAS
    ddtSym    = '$' { digit | letter }.
    optionSym = '$' letter { letter } '='
                { digit | letter
                | '-' | '.' | ':'
                }.

    comment1 = "/*" {'/' | other | '*' {'*'} other} '*' {'*'} '/'. //TODO: NESTED comments not supported!
        (. if(!in_verbatim) output() << la->val; .)
    comment2 = "//" { no_lf } lf.
        (. if(!in_verbatim) output() << la->val; .)

IGNORE cr + lf + tab

/*-------------------------------------------------------------------------*/

PRODUCTIONS

Coco                            (. token_names.insert(L"EOF", L"EOF"); /* special token in both languages */ .)
=
                                (. auto pos_start_includes = la->pos; .)
  { ANY }                       (. auto pos_end_includes = la->pos;
                                   in_verbatim = false;
                                .)
                                
  "COMPILER" ident              (. output() << "grammar " << t->val << ";\n\n"
                                            << "@parser::header {\n"
                                            << copy_verbatim(pos_start_includes, pos_end_includes)
                                            << "\n}\n\n";

                                   auto pos_start_members = la->pos;
                                   in_verbatim = true;
                                .)
  { ANY }                       (. in_verbatim = false;
                                   output() << "@parser::members {\n"
                                            << copy_verbatim(pos_start_members, la->pos)
                                            << "\n}\n\n";
                                .)

  [ "IGNORECASE"                (. output() << "//" C2A_TODO "IGNORECASE not possible in ANTLR\n"; .)
  ]
  [ "CHARACTERS"                (. current_output = name_type::charset;
                                   output() << "// CHARACTERS from line " << std::to_wstring(t->line) << '\n';
                                .)
    { SetDecl }
  ]

                                (. current_output = name_type::token; .)
  [ "TOKENS"                    (. output() << "// TOKENS from line " << std::to_wstring(t->line) << '\n'; .)
    { TokenDecl<L""> }          (. output() << '\n'; .)
  ]
  [ "PRAGMAS"                   (. output() << "// PRAGMAS from line " << std::to_wstring(t->line) << '\n'; .)
    { TokenDecl<L"HIDDEN"> }    (. output() << '\n'; .)
  ]
  { "COMMENTS"                  (. output() << "// COMMENTS from line " << std::to_wstring(t->line) << '\n';
                                   output() << define_name(name_type::token, L"COMMENT_" + std::to_wstring(t->pos))
                                            << ": (\n";
                                   indent(+1);
                                .)
    "FROM" TokenExpr            (. output() << " .*?\n"; .)
    "TO" TokenExpr
    [ "NESTED"                  (. output() << '\n' << indent()
                                            << "// " C2A_TODO "implement NESTED for this COMMENT\n";
                                .)
    ]                           (. output() << indent(-1) << ") -> channel(HIDDEN);\n\n"; .)
  }                             (. output() << '\n'; .)
  { "IGNORE"                    (. output() << "// IGNORE from line " << std::to_wstring(t->line) << '\n';
                                   output() << define_name(name_type::token, L"IGNORE") << ": (\n"
                                            << indent(+1);
                                .)
    Set                         (. output() << ") -> skip;\n";
                                    indent(-1);
                                 .)
  }
                                (. output() << "//Coco default: ignore blanks\n"
                                            << define_name(name_type::token, L"IGNORE_WHITESPACE")
                                            << ": ' ' -> channel(HIDDEN);\n";
                                .)

  SYNC                          (. current_output = name_type::production;
                                   output() << "\n\n";
                                .)
  "PRODUCTIONS"                 (. output() << "// PRODUCTIONS from line " << std::to_wstring(t->line) << '\n'; .)
  { Production }
  "END" ident                   (. output() << "\n\n" << tokens.str()
                                            << "\n\n" << characters.str();
                                .)
  '.'
  EOF
.


Production
=
    ident                       (. output() << define_name(name_type::production, std::wstring(t->val)); .)
    [ AttrDecl ]
                                (. output() << ":\n";
                                   indent(+1);
                                .)
    [                           (. output() << indent(); .)
      SemText                   (. output() << '\n'; .)
    ]
    WEAK '='
    Expression                  (. output() << '\n' << indent() << ";\n";
                                   indent(-1);
                                .)
    WEAK '.'                    (. output() << '\n'; .)
.


/*------------------------------------------------------------------------------------*/

SetDecl
=
  ident                         (. output() << "fragment " << define_name(name_type::charset, t->val)
                                            << ":\n" << indent(+1);
                                .)
  '=' Set
  '.'                           (. output() << '\n' << indent() << ";\n\n";
                                   indent(-1);
                                .)
.

/*------------------------------------------------------------------------------------*/

Set
=
  SimSet
  { '+'                         (. output() << '\n' << indent() << "| "; .)
    SimSet
  | '-'                         (. output() << '\n' << indent()
                                            << "//" C2A_TODO "the following subset was substracted from the previous, reformulate for ANTLR"
                                            << '\n' << indent() << "~("; .)
    SimSet                      (. output() << ")\n"; .)
  }
.

/*------------------------------------------------------------------------------------*/

SimSet
=
( ident                         (. if(charset_names.contains_key(t->val))
                                       output() << charset_names.at(t->val);
                                .)
|                               (. std::wstring chars; .)
  String<chars>                 (. // remove "-" if in chars, because in ANTLR it denotes character range
                                   auto removed = std::remove(chars.begin(), chars.end(), '-');
                                   if(removed != chars.end())
                                       output() << "'-' | ";
                                   chars.erase(removed, chars.end());

                                   output() << '[' << chars << ']';
                                .)
|                               (. std::wstring name; .)
  Char<name>                    (. output() << name; .)
  [ ".." Char<name>             (. output() << ".." << name; .)
  ]
| "ANY"                         (. output() << '.'; .)
)
.

Char<std::wstring& name>
=
    char                        (. name = std::wstring(t->val);

                                   size_t pos = -2;
                                   while (pos = name.find(L'\\', pos+2)) {
                                       if(pos == std::wstring::npos)
                                           break; // no more escapes

                                       const auto& escaped = name[pos+1];
                                       if (coco_and_antlr_escaped_chars.find(escaped) == std::wstring::npos) {
                                           // some non-common escape char
                                           output() << "/*" C2A_TODO "escaped character, check meaning: */";
                                           break;
                                       }
                                   }
                                .)
.

String<std::wstring& name>
=   string                      (. name = std::wstring(t->val);
                                   name = name.substr(1, name.length() -2); // remove ""
                                   if(name.find(L'\\') != std::wstring::npos)
                                       output() << "/*" C2A_TODO "escaped characters in string, check meaning: */ ";
                                   for(auto pos = name.find(L'\'');
                                       pos != std::wstring::npos;
                                       pos = name.find(L'\'', pos+2))
                                   {
                                       name.replace(pos, 1, L"\\'");
                                   }
                                .)
.

/*------------------------------------------------------------------------------------*/

TokenDecl<std::wstring channel> (. std::wstring name; bool is_literal; .)
=
  Sym<name, is_literal>
                                (. if(is_literal) {
                                       // raw string or char token, coco has no name for it
                                       output() << "LITERAL_" << std::to_wstring(literal_token_index)
                                              << ':' << name;
                                       ++literal_token_index;
                                   } else {
                                       output() << define_name(name_type::token, name) << ':';
                                   }
                                .)
  SYNC                          (. output() << '\n';
                                   indent(+1);
                                   if(! channel.empty())
                                       output() << indent() << "(\n";
                                .)
  ( '=' TokenExpr '.'
  |                             (. output() << " //" C2A_TODO "named token without body from Coco\n"; .)
  )
  [                             (. output() << '\n' << indent(); .)
    SemText
  ]
                                (. if(! channel.empty()) {
                                       output() << '\n' << indent() << ')';
                                       output() << "-> channel(" << channel << ')';
                                   }
                                   output() << '\n' << indent() << ";\n\n";
                                   indent(-1);
                                .)
.

/*------------------------------------------------------------------------------------*/

AttrDecl //TODO: parameter conflicts with rule with same name
=
  '<'                           (. auto pos_start = la->pos;
                                   output() << '[';
                                   in_verbatim = true;
                                .)
  { ANY | badString }
  '>'                           (. output() << copy_verbatim(pos_start, t->pos) << ']';
                                   in_verbatim = false;
                                .)
| "<."                          (. auto pos_start = la->pos;
                                   output() << '[';
                                   in_verbatim = true;
                                .)
  { ANY | badString }
  ".>"                          (. output() << copy_verbatim(pos_start, t->pos) << ']';
                                   in_verbatim = false;
                                .)
.

/*------------------------------------------------------------------------------------*/

Expression
=                               (. output() << indent(); .)
  Term
  { WEAK '|'                    (. output() << '\n' << indent(-1) << "|\t";
                                   indent(+1);
                                .)
    Term
  }
.

Term
=
(   [ Resolver ]
    Factor
    {                           (. output() << '\n' << indent(); .)
        Factor
    }
|
)
.

Factor
=
  [ "WEAK" ]                    (. std::wstring name; bool is_literal; .)
  Sym<name, is_literal>
                                (. if(is_literal) {
                                       output() << name;
                                   } else {
                                       if(token_names.contains_key(name)) {
                                           output() << token_names.at(name);
                                       } else {
                                           if(! production_names.contains_key(name)) {
                                               SemErr(std::wstring(L"name not defined yet: " + name).c_str()); // actually a warning only
                                           }
                                           output() << define_name(name_type::production, name);
                                       }
                                   }
                                 .)
  [ Attribs ]
| '('                           (. output() << "(\n"; indent(+1); .)
   Expression ')'               (. output() << '\n' << indent(-1) << ')'; .)
| '['                           (. output() << "(\n"; indent(+1); .)
   Expression ']'               (. output() << '\n' << indent(-1) << ")?"; .)
| '{'                           (. output() << "(\n"; indent(+1); .)
   Expression '}'               (. output() << '\n' << indent(-1) << ")*"; .)
| SemText
| "ANY"                         (. output() << '.';
                                   if(current_output == name_type::production)
                                       output() << " /*" C2A_TODO "implement Coco ANY in ANTLR lexer, not possible in parser */\n"; .)
| "SYNC"
.

/*------------------------------------------------------------------------------------*/

Resolver
=
  "IF" "("                       (. auto pos_start = la->pos; int end_pos;
                                    output() << "/* " C2A_TODO "IF() conflict resolver from Coco, check ANTLR code:\n";
                                    in_verbatim = true;
                                 .)
  Condition<end_pos>             (. output() << copy_verbatim(pos_start, end_pos) << "\n*/\n" << indent();
                                    in_verbatim = false;
                                 .)
.

Condition<int& end_pos>
= { "(" Condition<end_pos> | ANY } ")"
                                (. end_pos = t->pos + 1; .)
.

/*------------------------------------------------------------------------------------*/

TokenExpr
=                               (. output() << indent(); .)
  TokenTerm
  {
    WEAK '|'                    (. output() << '\n' << indent(-1) << "|\t";
                                   indent(+1);
                                .)
    TokenTerm
  }
.

TokenTerm
=
  TokenFactor
  {                             (. output() << '\n' << indent(); .)
    TokenFactor
  }
  [ "CONTEXT"                   (. output() << '\n' << indent() << "/*" C2A_TODO "CONTEXT specification not supported in ANTLR\n"; .)
    '(' TokenExpr               (. output() << "*/\n"; .)
    ')'
  ]
.

TokenFactor                     (. std::wstring name; bool is_literal; .)
=
  Sym<name, is_literal>
                                (. if(is_literal) {
                                       output() << name;
                                   } else {
                                       if (! charset_names.contains_key(name)) {
                                           SemErr(std::wstring(L"Character Class used but not defined: "
                                                               + name).c_str());
                                           output() << name;
                                       } else {
                                           output() << charset_names.at(name);
                                       }
                                   }
                                .)
| '('                           (. output() << "(\n"; indent(+1); .)
    TokenExpr ')'               (. output() << '\n' << indent(-1) << ')'; .)
| '['                           (. output() << "(\n"; indent(+1); .)
    TokenExpr ']'               (. output() << '\n' << indent(-1) << ")?"; .)
| '{'                           (. output() << "(\n"; indent(+1); .)
    TokenExpr '}'               (. output() << '\n' << indent(-1) << ")*"; .)
.

/*------------------------------------------------------------------------------------*/

Sym<std::wstring& name, bool& is_literal>
=
( ident                         (. name = std::wstring(t->val);
                                   is_literal = false;
                                .)
| String<name>                  (. name = L"'" + name + L"'";
                                   is_literal = true;
                                .)
| Char<name>                    (. is_literal = true; .)
)
.

/*------------------------------------------------------------------------------------*/

Attribs
=
  '<'                           (. auto pos_start = la->pos;
                                   output() << '[';
                                   in_verbatim = true;
                                .)
  { ANY | badString }           (. output() << copy_verbatim(pos_start, la->pos) << ']';
                                   in_verbatim = false;
                                .)
  '>'
| "<."                          (. auto pos_start = la->pos;
                                   output() << '[';
                                   in_verbatim = true;
                                .)
  { ANY | badString }           (. output() << copy_verbatim(pos_start, la->pos) << ']';
                                   in_verbatim = false;
                                .)
  ".>"
.

SemText
=
  "(."                          (. auto pos_start = la->pos;
                                   in_verbatim = true;
                                .)
  { ANY | badString | "(." }    (. output() << "{ " << copy_verbatim(pos_start, la->pos) << " }";
                                   in_verbatim = false;
                                .)
  ".)"
.

END Coco.
